# What is this?

As if this writing, the status of this component is: theoretical, this is all
wishfull thinking.

A filesystem component for the k operating system, inspired by
[Nayuki's](https://www.nayuki.io/page/designing-better-file-organization-around-tags-not-hierarchies)
tag based filesystem post.

The goal is to build on component that you can use to build complete
applications, so nayukiFs needs to support a number of different ways accessing
and storing data.

We provide an efficient capnproto based RPC mechanism for accessing the service.
This is statically typed and objected oriented. There are several types of
tagged objects made available over our RPC.

 * Files, which are basic, immutable, copy-on-write file objects. You can't edit
   them, you can only make a new copy of them and mark the old one as out of
   date. They are generally addressed by an sha256sum.
 * MutableFiles, which are traditional unix files. They don't work very well in
   clusters though. They exist for reasons of backwards compatability, and where
   possible we recomend you use the `Files` api instead. Addressable by UUID.
 * Streams, which are a lot like an unorderd mqtt stream. You can simply publish
   or subscribe a message to a set of tags.

Later on, it's intended to be the hub service for a set of "serverless"
distributed computing tools.

# Architecture

As a component of the k operating system, the main way of interacting with it is
over a capnproto RPC interface.

It's object-oriented interface is inspired by django's ORM.

nayukiFs addresses content using hashes, so it is defacto copy-on-write. A
provision for temporary and special files, addressable via UUID, is intended.
A convenience method, `.latest()`, should be used to get the latest file
matching a query.

There's also intended to be a tag-based message-passing system, similar in usage
to mqtt.

Tags are somewhat complicated. Tags can be a namespace, storing a piece of
metadata. For example, the tag `ctime:1529250290` would be perfectly valid. Of
course in a user-interface you probably want to represent that as something
human-readable.

# Building

We use tup as our build system. If you just want to get this installed, and not
do actual development, you can use the `quickBuild.sh` generated by tup to
build, even if you don't have tup installed.

Whenever you make significant changes, please run `tup generate quickBuild.sh`
to update the quickbuild.

Building requires several command line tools.

 * Nim, the compiler for the nim language (which itself relies on gcc)
 * Nimble, the nim-lang package manager
 * capnp, the code generator for the capnproto schema language
 * [capnp-nim](https://github.com/zielmicha/capnp.nim), the nim-lang extentions
   for capnproto. 

# Storages

## LMDB based storage

LMDB is very fast, and on 64-bit unixes it makes more sense to just store file
content in the LMDB database itself, rather than store it in the filesystem
layer.

Queries run in something like `O(min(len(s1), len(s2)))`, lookups by ID are `O(1)`.
This means we should be faster than conventional filesystems as long as one of
your tags doesn't include a huge number of objects.
